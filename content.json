{"meta":{"title":"YZH&博客","subtitle":"不会真有人摆烂吧","description":"开干开干","author":"杨征昊","url":"http://example.com","root":"/"},"pages":[{"title":"Hello World","date":"2022-05-11T14:34:40.927Z","updated":"2022-05-11T08:10:19.587Z","comments":true,"path":"hello-world.html","permalink":"http://example.com/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"tags","date":"2022-05-11T13:08:35.000Z","updated":"2022-05-11T13:08:35.406Z","comments":true,"path":"tags/index-1.html","permalink":"http://example.com/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2022-05-15T02:21:28.000Z","updated":"2022-05-15T02:21:28.310Z","comments":true,"path":"tags/index-2.html","permalink":"http://example.com/tags/index-2.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-11T13:08:23.000Z","updated":"2022-05-11T13:24:23.412Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-05-11T13:08:51.000Z","updated":"2022-05-11T13:24:55.328Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"建立博客咯","slug":"helloworld","date":"2022-05-11T08:15:42.000Z","updated":"2022-05-11T14:34:37.995Z","comments":true,"path":"2022/05/11/helloworld/","link":"","permalink":"http://example.com/2022/05/11/helloworld/","excerpt":"","text":"","categories":[],"tags":[{"name":"helloworld","slug":"helloworld","permalink":"http://example.com/tags/helloworld/"}]},{"title":"vue","slug":"vue","date":"2021-09-11T08:15:42.000Z","updated":"2022-05-11T14:34:09.371Z","comments":true,"path":"2021/09/11/vue/","link":"","permalink":"http://example.com/2021/09/11/vue/","excerpt":"","text":"vueSoc：HTML+CSS+JS：视图：给用户看，刷新后台给的数据 网络通信：axios 页面跳转：vue-router 状态管理：vuex Vue-UI：ICE 虚拟Dom：利用内存； 计算属性–&gt;Vue特特色 集大成者：MVVM+Dom 大前端时代：后端：轻松 裁员：好事","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"SpringBoot及Java8特性","slug":"Spring Boot及Java8特性","date":"2021-07-15T08:15:42.000Z","updated":"2022-05-15T03:37:45.997Z","comments":true,"path":"2021/07/15/Spring Boot及Java8特性/","link":"","permalink":"http://example.com/2021/07/15/Spring%20Boot%E5%8F%8AJava8%E7%89%B9%E6%80%A7/","excerpt":"","text":"BigDecimal四舍五入12345678910111213divide(new BigDecimal(1),1,BigDecimal.ROUND_HALF_UP) for (String key : results.keySet())&#123; ProcurementCountBudgetStatistic procurementCountBudgetStatistic = results.get(key); BigDecimal divide = procurementCountBudgetStatistic.getBudget().divide(new BigDecimal(10000), 1, BigDecimal.ROUND_HALF_UP); procurementCountBudgetStatistic.setBudget(divide); &#125;for (ProjectByTypes projectByTypes : serve1) &#123; BigDecimal Budget = projectByTypes.getAmount(); Budget.divide(new BigDecimal(10000),1, BigDecimal.ROUND_HALF_UP); projectByTypes.setAmount(Budget.divide(new BigDecimal(10000),1, BigDecimal.ROUND_HALF_UP));&#125; Stream流将list 转为 Map1Map&lt;Integer,String&gt; userMap1 = userList.stream().collect(Collectors.toMap(User::getId,User::getName)) Map装载+排序12345678910111213141516SectionCheckAndCheckItemVo sectionCheck = sectionCheckDao.getById(sessionCheckId, MapFunctions.plainPojoMapper(SectionCheckAndCheckItemVo.class));List&lt;SectionCheckOptionResultListVo&gt; resultPojos = sectionCheckOptionResultDao.findPojoBySectionCheckId(sessionCheckId, MapFunctions.plainPojoMapper(SectionCheckOptionResultListVo.class));List&lt;SectionCheckSubOptionResultVo&gt; subResultPojos = sectionCheckSubOptionResultDao.findPojoBySectionCheckId(sessionCheckId, MapFunctions.plainPojoMapper(SectionCheckSubOptionResultVo.class));HashMap&lt;Integer, List&lt;SectionCheckSubOptionResultVo&gt;&gt; subOptionResultMap = subResultPojos.stream() .collect( Collectors.groupingBy(SectionCheckSubOptionResultVo::getSectionCheckOptionResultId, HashMap::new, Collectors.collectingAndThen( Collectors.toList(), list -&gt; &#123; list.sort(Comparator.comparing(SectionCheckSubOptionResultVo::getPointCode)); return list; &#125; ) ) ); 在Map中通过ID（第一项）取数据 1List&lt;SectionCheckSubOptionResultVo&gt; resultVos = subOptionResultMap.get(sectionCheckOptionResultVo.getId()); Entity转Vo1234567List&lt;AttachmentVO&gt; collect = list.stream().map(entity -&gt;&#123; AttachmentVO attachmentVO = new AttachmentVO(); attachmentVO.setId(entity.getId()); attachmentVO.setName(entity.getName()); return attachmentVO;&#125;).collect(Collectors.toList()); JavaBean继承父类后1@EqualsAndHashCode(callSuper = true) 装载父类 Optional用法1234567public void whenEmptyValue_thenReturnDefault() &#123; User user = null; User user2 = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;); User result = Optional.ofNullable(user).orElse(user2); //为空使用默认值User2 assertEquals(user2.getEmail(), result.getEmail());&#125; 123456@Test(expected = IllegalArgumentException.class)public void whenThrowException_thenOk() &#123; User result = Optional.ofNullable(user) .orElseThrow( () -&gt; new IllegalArgumentException());&#125;为空抛出异常 文件上传下载 cn.hutool.core.io包文件上传文件上传： 123456789@ApiOperation(value = &quot;上传附件&quot;) @PostMapping(&#123;&quot;/upload&quot;&#125;) public Result&lt;Boolean&gt; uploadFile(Integer sectiontCheckSubOptionId, MultipartFile uploadFile) &#123; // 上传附件接口 if (null == uploadFile) &#123; return Result.error(&quot;文件为空&quot;); &#125; return Result.ok(fileService.updateFile(sectiontCheckSubOptionId, uploadFile)); &#125; 存进数据库+写进本地： 123456789101112131415161718public boolean updateFile(Integer sectiontCheckSubOptionId, MultipartFile file) throws Exception&#123; String path = buildPath(sectiontCheckSubOptionId.toString()); String allPath = path + &quot;/&quot; + file.getOriginalFilename(); FileUtil.mkParentDirs(allPath); try (FileOutputStream outputStream = new FileOutputStream(allPath))&#123; IoUtil.copy(file.getInputStream(), outputStream); &#125; //存储进数据库 AttachmentEntity attachmentEntity = new AttachmentEntity(); attachmentEntity.setName(file.getOriginalFilename()); attachmentEntity.setUrl(allPath); attachmentEntity.setSectiontCheckSubOptionId(sectiontCheckSubOptionId); //添加时间数据 Date date = new Date(); attachmentEntity.setUpdateTime(date); attachmentDao.save(attachmentEntity); return true; &#125; 创建本地路径 文件下载1234567891011 @ApiOperation(value = &quot;读取附件&quot;) @RequestMapping( value = &#123;&quot;/downLoadFile&quot;&#125;, method = &#123;RequestMethod.GET&#125; ) public void DownloadFile(Integer id , HttpServletRequest request, HttpServletResponse response ) throws Exception&#123; //下载附件接口 fileService.findFile(id,request,response); &#125;&#125; w 12345public void findFile (Integer id , HttpServletRequest request, HttpServletResponse response) throws Exception &#123; AttachmentEntity attachmentEntity = attachmentDao.selectById(id); DowloadFileHelper.setResponseFilename(attachmentEntity.getName(), response, request); this.returnFileStream(attachmentEntity.getUrl(), response);&#125; 将本地文件写进数据流 1234567891011121314 private void returnFileStream(String filePath, HttpServletResponse response) throws IOException &#123; File file = new File(filePath); if (!file.exists()) &#123; throw new RuntimeException(&quot;找不到文件: &quot; + filePath); &#125; try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(file))) &#123; try (OutputStream outputStream = response.getOutputStream()) &#123; IoUtil.copy(inputStream, outputStream); &#125; &#125; response.flushBuffer(); &#125;&#125; 将FileName添加进头部： 12345678910111213141516171819202122import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class DowloadFileHelper &#123; public DowloadFileHelper() &#123; &#125; public static void setResponseFilename(String filename, HttpServletResponse response, HttpServletRequest request) throws UnsupportedEncodingException &#123; response.setContentType(&quot;application/force-download&quot;); String agent = request.getHeader(&quot;User-Agent&quot;).toUpperCase(); if (!agent.contains(&quot;MSIE&quot;) &amp;&amp; !agent.contains(&quot;TRIDENT&quot;) &amp;&amp; !agent.contains(&quot;EDGE&quot;)) &#123; response.addHeader(&quot;Content-Disposition&quot;, String.format(&quot;attachment;fileName=\\&quot;%s\\&quot;&quot;, new String(filename.getBytes(StandardCharsets.UTF_8), StandardCharsets.ISO_8859_1))); &#125; else &#123; response.addHeader(&quot;Content-Disposition&quot;, String.format(&quot;attachment;fileName=\\&quot;%s\\&quot;&quot;, URLEncoder.encode(filename, &quot;utf-8&quot;))); &#125; response.addHeader(&quot;DownloadFileName&quot;, URLEncoder.encode(filename, &quot;utf-8&quot;)); &#125;&#125; 返回pojo类型数据，方便转换为Vo具体方法： 1public &lt;POJO&gt; List&lt;POJO&gt; findPojoBySectionCheckId(Integer sectionCheckId, MapFunction&lt;POJO&gt; function) 调用： 1List&lt;SectionCheckOptionResultListVo&gt; resultPojos = sectionCheckOptionResultDao.findPojoBySectionCheckId(sessionCheckId, MapFunctions.plainPojoMapper(SectionCheckOptionResultListVo.class)); poi-tl写入docx文件在service 写入数据 1234commonInspectService.generateNotifyDocument( Constants.PibsQssmInspectNotifyDocumentName.INSPECT_NOTIFY_DOCUMENT_NAME, Constants.PibsQssmInspectNotifyDocumentName.INSPECT_NOTIFY_FILE_PATH, notifyData, request, response); 给出文件名 文件地址 数据 及request response 即可 将一些数据写入docx 12345678public void generateNotifyDocument(String fileName, String filePath, InspectNotifyData inspectNotifyData, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; DowloadFileHelper.setResponseFilename(fileName, response, request); InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(filePath); XWPFTemplate template = XWPFTemplate.compile(resourceAsStream).render(inspectNotifyData); GenerateWordUtil.writeToResponse(response, template);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Spring","slug":"Spring","date":"2021-07-12T08:15:42.000Z","updated":"2022-05-15T03:36:20.646Z","comments":true,"path":"2021/07/12/Spring/","link":"","permalink":"http://example.com/2021/07/12/Spring/","excerpt":"","text":"Maven配置12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.8&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 优点 Spring是一个轻量级的 控制反转（IOC）和面向切面编程（AOP）的框架（容器） 轻量级、非入侵式的框架 控制反转（IOC），面向切面编程（AOP） 支持事务的处理，对框架整合的支持 组成 拓展 Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速的开发单个微服务 约定大于配置 Spring Cloud 基于SpringBoot 因为现在大多数公司都在使用SpringBoot进行开发 需要提前掌握Spring与SpringMVC！承上启下 IOC理论推导1.UserDao接口2.UserDaolmpl实现类3.UserService业务接口4.UserServicelmpl业务实现类 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ 我们使用一个Set接口实现.已经发生了革命性的变化！ 1234private Userpao userDao；//利用set进行动态实现值的注入！public void setUserDao（UserDao userDao）&#123;this.userDao=userDao； 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！ 这种思想，从本质上解决了问题，我们程序猿不用再去管理对象的创建了。系统的耦合性大大降低~，可以更加专注的在业务的实现上！这是IOC的原型！ IOC创建对象的方式1.使用无参构造创建对象，默认！2.假设我们要使用有参构造创建对象。1.下标赋值 1234&lt;！--第一种，下标赋值！--&gt; &lt;bean id=&quot;user&quot;class=&quot;com.kuang.pojo.user&quot;&gt; &lt;constructor-arg index=&quot;0&quot;value=&quot;狂神说Java&quot;/&gt;&lt;/bean&gt; 2.类型 1234&lt;！--第二种方式：通过类型创建，不建议使用！--&gt;&lt;bean id=&quot;user&quot;class=&quot;com.kuang.pojo.user&quot;&gt;&lt;constructor-arg type=&quot;java.lang.string&quot;value=&quot;qinjiang&quot;/&gt;&lt;/bean&gt; 3.别名 12&lt;！--别名，如果添加了别名，我们也可以使用别名获取到这个对象--&gt;&lt;alias name=&quot;user&quot;alias=&quot;userNew&quot;/&gt; 4.Bean的配置 12345678910&lt;！--id:bean的唯一标识符，也就是相当于我们学的对象名class:bean对象所对应的全限定名：包名+类型name：也是别名，而且name可以同时取多个别名--&gt; &lt;bean id=&quot;userT&quot;class=&quot;com.kuang.pojo.userT&quot;name=&quot;user2 u2，u3；u4&quot;&gt;&lt;property name=&quot;name&quot;value=&quot;西部开源&quot;/&gt;&lt;/bean&gt; 5.import这个import，一般用于团队开发使用，他可以将多个配置文件，导入合并为一个假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的xml合并为一个总的，使用的时候使用总的配置。 构造器注入123456789101112@Controllerpublic` `class` `FooController &#123; ``private` `final FooService fooService; ``@Autowired ``public` `FooController(FooService fooService) &#123; ``this``.fooService = fooService; ``&#125; ``//使用方式上同，略&#125; Set方式注入 依赖注入：Set注入！ 依赖：bean对象的创建依赖于容器！ 注入：bean对象中的所有属性，由容器来注入 [环境搭建] 1.复杂类型 1234567public class Address &#123;private string address; public string getAddress)&#123;return address; public void setAddress(string address)&#123;this. address=address; &#125;&#125; 2.真实测试对象 12345678910public class student &#123;private string name;private Address address;private string[] books; private List&lt;string&gt; hobbys;private Map&lt;string,string&gt;card; private Set&lt;string&gt; games; private string wife; private Properties info;&#125; 3.beans.xml 123456789&lt;？xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;？&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;bean id=&quot;student&quot;class=&quot;com.kuang.pojo.student&quot;&gt;&lt;！--第一种，普通值注入，value--&gt;&lt;property name=&quot;name&quot;value=&quot;秦疆&quot;/&gt;&lt;/bean&gt;&lt;/beans&gt; 4.测试类 1234567public class MyTest &#123;public static void main(string[] args)&#123;Applicationcontext context=new classPathxmlApplicationcontext(&quot;beans. xml&quot;); student student=(student) context. getBean(&quot;student&quot;); system. out. println(student. getAddress()); &#125;&#125; 拓展方式注入c构造和p构造要导入约束 12345678910&lt;？xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;？&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;！--p命名空间注入，可以直接注入属性的值：property--&gt;&lt;bean id=&quot;user&quot;class=&quot;com.kuang.pojo.user&quot;p:name=&quot;秦疆&quot;p:age=&quot;18&quot;/&gt;&lt;！--c命名空间注入，通过构造器注入：construct-args--&gt;&lt;bean id=&quot;user2&quot;class=&quot;com.kuang.pojo.User&quot;c:age=&quot;18&quot;c:name=&quot;狂神&quot;/&gt;&lt;/beans&gt; Bean的作用域 1.单例模式（Spring默认） 12&lt;bean id=&quot;user2&quot;class=&quot;com.kuang.pojo.User&quot;c:age=&quot;18&quot;c:name=&quot;狂神&quot;scope=&quot;singleton&quot;/&gt; 2.原型模式：每次从容器中get1的时候，都会产生一个新对象。 12&lt;bean id=&quot;accountservice&quot;class=&quot;com.something.pefaultAccountservice&quot;scope=&quot;prototype&quot;/&gt; 3.其他requset，session，application只能在web开发中用到 Bean的自动装配 自动装配是Spring满足bean依赖一种方式！ Spring会在上下文中自动寻找，并自动给bean装配属性！ 在Spring中有三种装配的方式 1.在xml中显示的配置 2.在java中显示配置 3.隐式的自动装配bean 测试根据名字 所有bean的id唯一 bean要和自动注入的属性set方法的值一致！ 123456&lt;!--byName：会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid！ --&gt;&lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byName&quot;&gt;&lt;property name=&quot;name&quot; value=&quot;小狂神呀&quot;/&gt;&lt;/bean&gt; 根据类型 所有bean的class唯一 且这个bean要和自动注入的属性类型一致！ 123x &lt;!--byName：会自动在容器上下文中查找，和自己对象属性配型相同的bean --&gt;&lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小狂神呀&quot;/&gt;&lt;/bean&gt; 1.导入约束 context约束 2.配置注解的支持 context:annotation-config/ 123456789&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttps://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired 直接在属性上使用即可！也可以在set方式上使用！ 使用Autowired 我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC（Spring）容器中存在，且符合名字byname！ 1@Nullable 说明这个字段可以为空 123public @interface Autowired &#123;boolean required() default true;&#125; 123456789public class People&#123;/∥如果显示定义Autowired的required属性为false，说明这个对象可以为nu11，否则不允许为空@Autowired（required=false）private cat cat；@Autowiredprivate Dog dog；private string name；&#125; 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用@Qualifier（value&#x3D;”xxx’”）去配置@Autowired的使用，指定一个唯一的bean对象注入！ @Resource 先通过名字匹配 匹配不到通过class匹配 123456public class People &#123;@Resource(name =&quot;cat2&quot;)private cat cat; @Resource private Dog dog;&#125; 小结：@Resource 和@Autowired的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】 执行顺序不同：Autowired默认通过byType @Resource默认通过byname 衍生的注解@Component 有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！ dao【@Repository】 service【@Service】 controller【@Controller】 这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean自动装配置@Autowired：自动装配通过类型。名字如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier（value&#x3D;”xxx”）@Nu1lable字段标记了这个注解，说明这个字段可以为nu11；@Resource：自动装配通过名字。类型。 xml与注解： xml更加万能，适用于任何场合！维护简单方便 注解不是自己类使用不了，维护相对复杂！ xml与注解最佳实践： oxml 用来管理bean；。注解只负责完成属性的注入； 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持 AOPSpringAOP的底层—代理模式 代理模式分类： 静态代理 角色分析：抽象角色：一般会使用接口或者抽象类来解决真实角色：被代理的角色代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作客户：访问代理对象的人！ 静态代理模式的好处：可以使真实角色的操作更加纯粹！不用去关注一些公共的业务公共也就就交给代理角色！实现了业务分工业务扩展的时候 方便管理 动态代理 动态代理和静态代理角色一样动态代理的代理类是动态生成的，不是我们直接写好的！动态代理分为两大类：基于接口的动态代理，基于类的动态代理基于接口–JDK动态代理【我们在这里使用】基于类：cglib ojava字节码实现： javasist需要了解两个类：Proxy，Invokationl 动态代理的好处： 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务 公共也就就交给代理角色！实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要是实现了同一个接口即可！ 使用AOP 需要导入一个依赖包： 123456&lt;!--https://mvnrepository.com/artifact/org.aspectj/aspectjweaver--&gt;&lt;dependency&gt;&lt;groupId&gt;org.aspectj&lt;/groupId&gt;&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 方式一：使用Spring的API接口【主要SpringAPl接口实现】方式二：自定义来实现AOP【主要是切面定义】方式三：使用注解实现！|","categories":[],"tags":[{"name":"Java, Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"}]},{"title":"MYSQL","slug":"MySQL","date":"2021-05-18T08:15:42.000Z","updated":"2022-05-11T14:33:03.212Z","comments":true,"path":"2021/05/18/MySQL/","link":"","permalink":"http://example.com/2021/05/18/MySQL/","excerpt":"","text":"MySQL数据库分类关系型数据库（SQL） MySQL,Oracle,Sql Server,DB2,SQLite 通过表和表之间，行和列之间的关系进行数据的存储 非关系型数据库（NoSQL）Not Only Redis，MongDB 非关系型数据库，对象存储，通过对象自身的属性来决定 DBMS（数据库管理系统） 数据库的管理软件 管理数据库 单行注释：– 多行注释： &#x2F;* *&#x2F; 数据类型数值 tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小的数据 3个字节 int 标准的整数 4个字节常 用的int bigint 较大的数据 8个字节 float 浮点数 4个字节 double 浮点数 8个字节（精度问题！） decimal 字符串形式的浮点数金融计算的时候，一般是使用decimal 字符串 char 字符串固定大小的 0-255 varchar 可变字符串 0~65535 常用的变量 String tinytext 微型文本 2^8-1 text 文本串 2^16-1 保存大文本 时间日期 java.util.Date date YYYY-MM-DD 日期格式 time HH:mm:ss 时间格式 datetime YYYY-MM-DD HH:mm:ss 最常用的时间格式 timestamp 时间戳，1970.1.1到现在的毫秒数！ year 年份表示 null 没有值，未知 注意，不要使用NULL进行运算，结果为NULL 数据库的字段属性（重点）Unsigned： 无符号的整数 声明了该列不能声明为负数 zerofill： 0填充的 不足的位数，使用0来填充，int（3），5—005 自增： 通常理解为自增，自动在上一条记录的基础上+1（默认） 通常用来设计唯一的主键~index，必须是整数类型 可以自定义设计主键自增的起始值和步长 非空：NUll not null 设置not null 不赋值报错 Null 不填写值 默认null 默认 设置默认的值 sex，默认为男，如果不指定该列的值，则会有默认的值 12345678910//创建表CREATE TABLE[IF NOT EXISTS]表名（ &#x27;字段名&#x27; 列类型[属性] [索引] [注释]， &#x27;字段名&#x27; 列类型[属性] [索引] [注释]， &#x27;字段名&#x27; 列类型[属性] [索引] [注释]）[表类型][字符设置][注释]SHOW CREATE DATABASE school --查看创建数据库的语句SHOW CREATE TABLE student --查看student数据表的定义语句DESC student --显示表的结构 操作数据库修改、删除表12345678910111213141516--修改表名ALTER TABLE旧表名RENAME AS新表名ALTER TABLE teacher RENAME AS teacher1--增加表的字段ALTER TABLE 表名 ADD 字段名 列属性ALTER TABLE teacher1 ADD age INT（11）--修改表的字段（重命名，修改约束！）--ALTER TABLE 表名 MODIFY 字段名 列属性[]ALTER TABLE teacher1 MODIFY age VARCHAR（11）--修改约束--ALTER TABLE 表命 CHANGE 旧名字 新名字 列属性[]ALTER TABLE teacher1 CHANGE age agel INT（1）--字段重名名--删除表的字段ALTER TABLE teacherl DROP agel--删除表DROP TABLE IF EXISTS teacher 注意点： 字段名使用 &#96;&#96; 包裹 注释 – &#x2F;**&#x2F; sql关键字大小写不敏感 小写合适 所有的符号全部用英文","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Java语法补漏","slug":"Java语法补漏","date":"2021-05-11T08:15:42.000Z","updated":"2022-05-11T14:32:36.150Z","comments":true,"path":"2021/05/11/Java语法补漏/","link":"","permalink":"http://example.com/2021/05/11/Java%E8%AF%AD%E6%B3%95%E8%A1%A5%E6%BC%8F/","excerpt":"","text":"Java基础语法学习初始值Boolean 类型 初始值为false int、long、short：0 faloat、double：0.0 除了基本类型 都为null 变量作用域 实例变量：从属于对象 使用时需要实例化 局部变量：在方法内定义 Static：类变量 从属于类 加了static后可以方便调用 不需要实例化 final用来定义常量 Scanner对象Scanner s &#x3D; new Scanner(System.in) 先进行hasNext与hasNextLine判断是否有输入的数据 然后通 过Scanner类的next()和nextLine()方法获取数据 next()特性： 1.读取到有效字符后才可以结束输入 2.有效字符前空白会去掉 3.有效字符后面的空白会作为分隔符或者结束符 4.不能得到带有空格的字符串 nextLine()特性： 1.Enter为结束符 2.可以获得空白 用完写 s.close 方法重载名称相同 参数列表不同（个数不同，或类型不同，参数排列顺序不同等） 返回值类型可相同可不相同 仅仅返回值不同不可以使用方法重载 可变长参数在指定参数类型后加：…（例如double… number） 即可获得可变参数 使用： number[0] number[1] 抽象类abstract 抽象方法 只有方法名字，没用方法的实现 extends：单继承 （接口可以多继承） 抽象类不能new 只能靠子类来实现它：约束 抽象类可以写普通方法 抽象方法必须在抽象类中 抽象的抽象：约束 接口只有规范 无法写方法，专业的约束！约束和实现分离：面向接口编程 接口的 本质是契约 抽象的精髓，是对对象的抽象，最能体现这一点的 就是接口，设计模式所研究的就是如何合理的去抽象 拥有抽象的思维 -java 架构师 方法 接口中的所有定义其实都是抽象的 public abstract 常量 定义的常量都是public static final 定义一些方法 让不同的人去实现 接口中可以定义默认方法 ：使用default关键字 注解1234567891011121314151617181920212223//注解可以显示赋值，如果没有默认值，我们就必须给注解赋值@MyAnnotation2(age=18,name=&quot;秦疆&quot;)public void test()&#123;&#125;@MyAnnotation3（&quot;秦疆&quot;）public void test2()&#123;&#125;@Target（&#123;ElementType.TYPE，ElementType.METHOD&#125;） @Retention（RetentionPolicy.RUNTIME）@interface MyAnnotation2&#123;//注解的参数:参数类型+参数名();String name（）default&quot;&quot;;int age（）;int id（）default -1；//如果默认值为-1，代表不存在。string[]schools（）default&#123;&quot;西部开源&quot;，&quot;清华大学&quot;&#125;;&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation3&#123;string value();&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java网络编程","slug":"网络编程","date":"2021-04-11T08:15:42.000Z","updated":"2022-05-11T14:34:29.453Z","comments":true,"path":"2021/04/11/网络编程/","link":"","permalink":"http://example.com/2021/04/11/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"获取IP地址123456//查询本机地址 InetAddress inetaddress = InetAddress.getByName(&quot;127.0.0.1&quot;);//查询本机地址InetAddress inetaddress = InetAddress.getLocalHost();//获取百度IP地址InetAddress inetaddress = InetAddress.getByName(&quot;www.baidu.com&quot;); 建立Socket通信 传输文件服务端：123456789101112131415161718//建立一个带端口的链接地址ServiceSocket serviceSocket = new ServiceSocket(9999);//等待客服端连接Socket socket = serverSocket.accept();//读取客户端的消息InputStream is = socket.getInputStream();//管道流接收ByteArrayOutputStream baos = new ByteArrayOutputStream();byte[] buffer = new byte[1024];int len;while((len = is.read(buffer))!=-1)&#123; baos.write(buffer,0,len);&#125;System.out.println(baos.toString)baos.close();is.close(); socket.close();serverSocket.close(); 客户端：12345678910//得到ip、端口InetAddress serverIP = Inet.getByName(&quot;127.0.0.1&quot;); int port = 9999;//创建一个连接Socket socket = new Socket(serverIP , port);//发送消息 IO流OutputStream os = socket.getOutputStream();os.write(&quot;Hello World&quot;.getBytes());os.close();socket.close(); UDP客户端12345678910//建立一个SocketDatagramSocket socket = new DatagramSocket;//建立一个包String mas = &quot;123&quot;;InetAddress localhost = InetAddress.getByName(&quot;localhost&quot;);int port = 9090;DaragramaPacket packet = new DaragramaPacket(msg.getBytes(),0,msg.length(),localhost , port);//发送包socket.send(packet);socket.close; 服务端1234567//设置端口DaragramaSocket socket = new DatagramSocket(9090);//接收数据包byte[] buffer = new byte[1024];DaragramaPacket packet = new DaragramaPacket(buffer , 0 , buffer.length);socket.receive(packet);socket.close(); 下载网上资源文件1234567891011121314151617//下载地址URL url = new URL(&quot;http://&quot;);//找到这个资源HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();InputStream inputStream = urlConnection .getInputStream;FileOutputStream fos = new fileOutputStream(&quot;q.jpg&quot;);byte[] buffer = new byte[1024];int len;while((len=inputStream.read(buffer))!=-1)&#123; fos.write(buffer,0,len);&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}],"categories":[],"tags":[{"name":"helloworld","slug":"helloworld","permalink":"http://example.com/tags/helloworld/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Java, Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]}